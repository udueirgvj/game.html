
<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„ØµØ­Ø±Ø§Ø¡ - Ø¨ÙˆØ¨Ø¬ÙŠ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }
        #info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 30px;
            font-size: 14px;
            backdrop-filter: blur(5px);
            z-index: 10;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.3);
        }
        #cam-status {
            position: absolute;
            top: 15px;
            right: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 30px;
            font-size: 14px;
            backdrop-filter: blur(5px);
            z-index: 10;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.3);
        }
        .touch-controls {
            position: absolute;
            bottom: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20;
            pointer-events: none;
        }
        .wasd-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }
        .wasd-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        .ctrl-btn {
            width: 70px;
            height: 70px;
            border-radius: 35px;
            background: rgba(50, 30, 10, 0.7);
            backdrop-filter: blur(10px);
            border: 2px solid #cd7f32; /* Ø¨Ø±ÙˆÙ†Ø²ÙŠ */
            color: #ffd966;
            font-size: 28px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s;
            touch-action: manipulation;
            text-shadow: 0 2px 5px black;
        }
        .ctrl-btn:active, .ctrl-btn.active {
            background: #cd7f32;
            color: white;
            transform: scale(0.9);
            border-color: gold;
        }
        .camera-btn {
            width: 80px;
            height: 80px;
            border-radius: 40px;
            background: rgba(100, 50, 20, 0.7);
            backdrop-filter: blur(10px);
            border: 2px solid #cd7f32;
            color: #ffd966;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        .camera-btn:active {
            background: #cd7f32;
            color: white;
        }
        @media (max-width: 600px) {
            .ctrl-btn { width: 60px; height: 60px; font-size: 24px; }
            .camera-btn { width: 70px; height: 70px; font-size: 16px; }
        }
    </style>
</head>
<body>
    <div id="info">ğŸœï¸ ØµØ­Ø±Ø§Ø¡ Ø¨ÙˆØ¨Ø¬ÙŠ | WASD Ù„Ù„Ø­Ø±ÙƒØ© | C Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</div>
    <div id="cam-status">ğŸ“· ÙƒØ§Ù…ÙŠØ±Ø§: Ø®Ù„ÙÙŠØ©</div>

    <div class="touch-controls">
        <div class="wasd-panel">
            <div class="wasd-row">
                <button class="ctrl-btn" id="btn-w">W</button>
            </div>
            <div class="wasd-row">
                <button class="ctrl-btn" id="btn-a">A</button>
                <button class="ctrl-btn" id="btn-s">S</button>
                <button class="ctrl-btn" id="btn-d">D</button>
            </div>
        </div>
        <button class="camera-btn" id="btn-c">C</button>
    </div>

    <!-- Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ø±Ù†Ø¯Ø± ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Ø³Ù…Ø§Ø¡ Ø²Ø±Ù‚Ø§Ø¡ ÙØ§ØªØ­Ø©
        scene.fog = new THREE.FogExp2(0xddaa88, 0.002); // Ø¶Ø¨Ø§Ø¨ Ø®ÙÙŠÙ Ø¨Ù„ÙˆÙ† ØµØ­Ø±Ø§ÙˆÙŠ

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.3;
        document.body.appendChild(renderer.domElement);

        // --- Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª ---
        const cameraFollow = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        cameraFollow.position.set(5, 3, 7);

        const cameraFree = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        cameraFree.position.set(15, 10, 20);

        let activeCamera = cameraFollow;
        const controls = new OrbitControls(cameraFree, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.enabled = false;

        // --- Ø§Ù„Ø¥Ø¶Ø§Ø¡Ø© Ø§Ù„ØµØ­Ø±Ø§ÙˆÙŠØ© (Ø´Ù…Ø³ Ù‚ÙˆÙŠØ©) ---
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffcc88, 1.8);
        sunLight.position.set(50, 60, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 120;
        sunLight.shadow.camera.left = -40;
        sunLight.shadow.camera.right = 40;
        sunLight.shadow.camera.top = 40;
        sunLight.shadow.camera.bottom = -40;
        sunLight.shadow.bias = -0.0005;
        sunLight.shadow.normalBias = 0.02;
        scene.add(sunLight);

        // Ø¥Ø¶Ø§Ø¡Ø© Ø®Ù„ÙÙŠØ© Ø¯Ø§ÙØ¦Ø©
        const backLight = new THREE.DirectionalLight(0xffaa66, 0.5);
        backLight.position.set(-30, 20, -40);
        scene.add(backLight);

        // --- Ø£Ø±Ø¶ÙŠØ© ØµØ­Ø±Ø§ÙˆÙŠØ© (Ø±Ù…Ù„ÙŠØ©) ---
        const textureLoader = new THREE.TextureLoader();
        // Ù†Ø³ÙŠØ¬ Ø±Ù…Ù„ Ù…Ù† three.js examples
        const sandColor = textureLoader.load('https://threejs.org/examples/textures/terrain/grass_01_diff_1k.jpg'); // Ù…Ø¤Ù‚ØªØŒ Ù„ÙƒÙ† Ø³Ù†Ø³ØªØ®Ø¯Ù… Ù„ÙˆÙ†Ø§Ù‹
        // Ù„ÙƒÙ† Ù„ØªØ¨Ø³ÙŠØ· Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©ØŒ Ù†Ø³ØªØ®Ø¯Ù… Ù„ÙˆÙ†Ù‹Ø§ Ù…Ø¹ ØªØ¶Ø§Ø±ÙŠØ³ Ø¨Ø³ÙŠØ·Ø©

        // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø±Ø¶ÙŠØ© ÙƒØ¨ÙŠØ±Ø© Ù…Ø¹ ØªÙ…ÙˆØ¬Ø§Øª Ø¨Ø³ÙŠØ·Ø© (Ù„ØªØ¨Ø¯Ùˆ ÙƒÙƒØ«Ø¨Ø§Ù†)
        const groundGeo = new THREE.PlaneGeometry(200, 200, 64, 64);
        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ù‚Ù…Ù… Ù„Ø¬Ø¹Ù„Ù‡Ø§ ÙƒØ«Ø¨Ø§Ù†Ø§Ù‹ Ø®ÙÙŠÙØ©
        const positionAttribute = groundGeo.attributes.position;
        for (let i = 0; i < positionAttribute.count; i++) {
            const x = positionAttribute.getX(i);
            const y = positionAttribute.getY(i);
            const z = positionAttribute.getZ(i);
            // Ø§Ø±ØªÙØ§Ø¹ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨Ø³ÙŠØ·
            const wave = Math.sin(x * 0.1) * Math.cos(z * 0.1) * 1.5 + Math.sin(x * 0.3) * 0.5;
            positionAttribute.setY(i, wave);
        }
        groundGeo.computeVertexNormals();

        const groundMat = new THREE.MeshStandardMaterial({
            color: 0xd2b48c, // Ù„ÙˆÙ† Ø±Ù…Ù„ÙŠ
            roughness: 0.8,
            emissive: 0x221100,
            flatShading: false
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2; // Ù†Ø³Ø·Ø­Ù‡Ø§ Ù„Ø£Ù†Ù†Ø§ Ø¹Ø¯Ù„Ù†Ø§ Ø§Ù„Ù‚Ù…Ù… ÙŠØ¯ÙˆÙŠÙ‹Ø§
        // Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªØ¯ÙˆÙŠØ± Ù„Ø£Ù†Ù†Ø§ Ø¹Ø¯Ù„Ù†Ø§ Ø§Ù„Ù‚Ù…Ù… Ù…Ø¨Ø§Ø´Ø±Ø©ØŒ Ø§Ù„Ø£ÙØ¶Ù„ Ù†ØªØ±ÙƒÙ‡Ø§ Ù…Ø³ØªÙˆÙŠØ© ÙˆÙ†Ø¶ÙŠÙ ÙƒØ«Ø¨Ø§Ù†Ù‹Ø§ ÙƒÙƒØ§Ø¦Ù†Ø§Øª Ù…Ù†ÙØµÙ„Ø© Ù„Ù„ØªØ¨Ø³ÙŠØ·
        // Ù„ÙƒÙ† Ø³Ù†Ø¨Ù‚ÙŠÙ‡Ø§ Ù…Ø³ØªÙˆÙŠØ© Ù…Ø¹ Ù†Ø³ÙŠØ¬ Ø±Ù…Ù„
        
        // Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø±Ø¶ÙŠØ© Ù…Ø³ØªÙˆÙŠØ© Ù…Ø¹ Ù†Ø³ÙŠØ¬
        const groundFlatGeo = new THREE.CircleGeometry(200, 64);
        const groundFlatMat = new THREE.MeshStandardMaterial({ color: 0xc2a477, roughness: 0.9 });
        const groundFlat = new THREE.Mesh(groundFlatGeo, groundFlatMat);
        groundFlat.rotation.x = -Math.PI / 2;
        groundFlat.position.y = 0;
        groundFlat.receiveShadow = true;
        scene.add(groundFlat);

        // --- ÙƒØ«Ø¨Ø§Ù† Ø±Ù…Ù„ÙŠØ© Ø¥Ø¶Ø§ÙÙŠØ© (Ù„Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©) ---
        for (let i = 0; i < 30; i++) {
            const duneGeo = new THREE.ConeGeometry(2 + Math.random() * 4, 0.8 + Math.random() * 1.5, 8);
            const duneMat = new THREE.MeshStandardMaterial({ color: 0xc9a87c });
            const dune = new THREE.Mesh(duneGeo, duneMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 60;
            dune.position.set(Math.cos(angle) * radius, 0.2, Math.sin(angle) * radius);
            dune.rotation.y = Math.random() * Math.PI;
            dune.castShadow = true;
            dune.receiveShadow = true;
            scene.add(dune);
        }

        // --- Ø«ÙŠÙ„ Ø¬Ø§Ù (Ø£Ø¹Ø´Ø§Ø¨ ØµØ­Ø±Ø§ÙˆÙŠØ©) ---
        const dryGrassMat = new THREE.MeshStandardMaterial({ color: 0xb89a6b });
        const grassBladeGeo = new THREE.ConeGeometry(0.2, 0.6, 4);
        for (let i = 0; i < 400; i++) {
            const grass = new THREE.Mesh(grassBladeGeo, dryGrassMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 80;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            grass.position.set(x, 0.3, z);
            grass.rotation.y = Math.random() * Math.PI;
            grass.castShadow = true;
            grass.receiveShadow = true;
            scene.add(grass);
        }

        // --- Ø´Ø®ØµÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ© ØªØ´Ø¨Ù‡ Ø´Ø®ØµÙŠØ§Øª Ø¨ÙˆØ¨Ø¬ÙŠ (ØªÙØ§ØµÙŠÙ„ Ø£ÙƒØ«Ø±) ---
        function createPUBGCharacter() {
            const group = new THREE.Group();

            // Ù…ÙˆØ§Ø¯
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xe0ac69, roughness: 0.4 });
            const shirtMat = new THREE.MeshStandardMaterial({ color: 0x6b4c3b, roughness: 0.7 }); // Ø²ÙŠ Ø¹Ø³ÙƒØ±ÙŠ Ø¨Ù†ÙŠ
            const pantsMat = new THREE.MeshStandardMaterial({ color: 0x4a3c31, roughness: 0.8 });
            const bootsMat = new THREE.MeshStandardMaterial({ color: 0x2c1e10 });
            const helmetMat = new THREE.MeshStandardMaterial({ color: 0x3a5f3a }); // Ø®ÙˆØ°Ø© Ø¹Ø³ÙƒØ±ÙŠØ©
            const vestMat = new THREE.MeshStandardMaterial({ color: 0x4a5f3a });
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

            // Ø§Ù„Ø¬Ø³Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ (ØµØ¯Ø±)
            const torsoGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.2);
            const torso = new THREE.Mesh(torsoGeo, vestMat);
            torso.castShadow = true;
            torso.receiveShadow = true;
            torso.position.y = 1.2;
            group.add(torso);

            // Ø§Ù„Ø±Ø£Ø³
            const headGeo = new THREE.SphereGeometry(0.45, 16);
            const head = new THREE.Mesh(headGeo, skinMat);
            head.castShadow = true;
            head.receiveShadow = true;
            head.position.y = 2.1;
            group.add(head);

            // Ø®ÙˆØ°Ø©/Ù‚Ø¨Ø¹Ø©
            const helmetGeo = new THREE.ConeGeometry(0.5, 0.3, 8);
            const helmet = new THREE.Mesh(helmetGeo, helmetMat);
            helmet.position.y = 2.4;
            helmet.castShadow = true;
            helmet.receiveShadow = true;
            group.add(helmet);

            // Ø¹ÙŠÙ†Ø§Ù†
            const eyeGeo = new THREE.SphereGeometry(0.08, 6);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-0.15, 2.2, 0.4);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(0.15, 2.2, 0.4);
            group.add(eyeR);

            // Ø§Ù„ÙÙƒ Ø§Ù„Ø³ÙÙ„ÙŠ (Ø¨Ø³ÙŠØ·)
            const jawGeo = new THREE.BoxGeometry(0.3, 0.1, 0.2);
            const jaw = new THREE.Mesh(jawGeo, skinMat);
            jaw.position.set(0, 2.0, 0.45);
            group.add(jaw);

            // Ø§Ù„Ø£Ø±Ø¬Ù„
            const legGeo = new THREE.CylinderGeometry(0.25, 0.25, 1.0);
            const legL = new THREE.Mesh(legGeo, pantsMat);
            legL.castShadow = true;
            legL.receiveShadow = true;
            legL.position.set(-0.3, 0.6, 0);
            group.add(legL);
            const legR = new THREE.Mesh(legGeo, pantsMat);
            legR.castShadow = true;
            legR.receiveShadow = true;
            legR.position.set(0.3, 0.6, 0);
            group.add(legR);

            // Ø£Ø­Ø°ÙŠØ©
            const bootGeo = new THREE.BoxGeometry(0.3, 0.2, 0.5);
            const bootL = new THREE.Mesh(bootGeo, bootsMat);
            bootL.castShadow = true;
            bootL.receiveShadow = true;
            bootL.position.set(-0.3, 0.1, 0.1);
            group.add(bootL);
            const bootR = new THREE.Mesh(bootGeo, bootsMat);
            bootR.castShadow = true;
            bootR.receiveShadow = true;
            bootR.position.set(0.3, 0.1, 0.1);
            group.add(bootR);

            // Ø§Ù„Ø°Ø±Ø§Ø¹Ø§Ù†
            const armGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.0);
            const armL = new THREE.Mesh(armGeo, shirtMat);
            armL.castShadow = true;
            armL.receiveShadow = true;
            armL.position.set(-0.7, 1.5, 0);
            armL.rotation.z = 0.2;
            group.add(armL);
            const armR = new THREE.Mesh(armGeo, shirtMat);
            armR.castShadow = true;
            armR.receiveShadow = true;
            armR.position.set(0.7, 1.5, 0);
            armR.rotation.z = -0.2;
            group.add(armR);

            // Ø¨Ù†Ø¯Ù‚ÙŠØ© Ø¨Ø³ÙŠØ·Ø© (Ø¹Ù„Ù‰ Ø§Ù„Ø¸Ù‡Ø±)
            const gunGroup = new THREE.Group();
            const gunBodyGeo = new THREE.BoxGeometry(0.1, 0.1, 1.0);
            const gunBody = new THREE.Mesh(gunBodyGeo, gunMat);
            gunBody.position.set(0, 0, 0);
            gunGroup.add(gunBody);
            const gunHandleGeo = new THREE.BoxGeometry(0.15, 0.3, 0.1);
            const gunHandle = new THREE.Mesh(gunHandleGeo, gunMat);
            gunHandle.position.set(0, 0.2, 0.3);
            gunGroup.add(gunHandle);
            gunGroup.position.set(0.4, 1.5, -0.4);
            gunGroup.rotation.x = 0.5;
            gunGroup.rotation.y = -0.3;
            group.add(gunGroup);

            return group;
        }

        const player = createPUBGCharacter();
        player.position.set(0, 0.5, 0);
        player.castShadow = true;
        player.receiveShadow = true;
        scene.add(player);

        // --- Ø£Ø´Ø¬Ø§Ø± Ù†Ø®ÙŠÙ„ ØµØ­Ø±Ø§ÙˆÙŠØ© ÙˆØ§Ù‚Ø¹ÙŠØ© ---
        function createPalmTree(x, z) {
            const group = new THREE.Group();

            // Ø¬Ø°Ø¹ Ø§Ù„Ù†Ø®ÙŠÙ„ (Ø·ÙˆÙŠÙ„ ÙˆÙ…Ù†Ø­Ù†ÙŠ Ù‚Ù„ÙŠÙ„Ø§Ù‹)
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B, roughness: 0.9 });
            const trunkGeo = new THREE.CylinderGeometry(0.7, 1.0, 6);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = 3;
            trunk.rotation.z = 0.1; // Ø§Ù†Ø­Ù†Ø§Ø¡ Ø·ÙÙŠÙ
            group.add(trunk);

            // Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ù†Ø®ÙŠÙ„ (Ø¹Ø¯Ø© Ù…Ø®Ø§Ø±ÙŠØ· Ø®Ø¶Ø±Ø§Ø¡ Ø­ÙˆÙ„ Ø§Ù„Ù‚Ù…Ø©)
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2d6a4f, roughness: 0.6 });
            const leafGeo = new THREE.ConeGeometry(1.2, 2.5, 6);

            for (let i = 0; i < 6; i++) {
                const leaf = new THREE.Mesh(leafGeo, leafMat);
                leaf.castShadow = true;
                leaf.receiveShadow = true;
                leaf.position.set(0, 6, 0);
                leaf.rotation.y = (i / 6) * Math.PI * 2;
                leaf.rotation.z = 0.5; // Ù…Ø§Ø¦Ù„ Ù„Ù„Ø®Ø§Ø±Ø¬
                leaf.rotation.x = 0.3;
                group.add(leaf);
            }

            // Ø£ÙˆØ±Ø§Ù‚ Ø¥Ø¶Ø§ÙÙŠØ© ØµØºÙŠØ±Ø©
            const smallLeafGeo = new THREE.ConeGeometry(0.8, 1.8, 5);
            for (let i = 0; i < 4; i++) {
                const leaf2 = new THREE.Mesh(smallLeafGeo, leafMat);
                leaf2.castShadow = true;
                leaf2.receiveShadow = true;
                leaf2.position.set(0, 5.2, 0);
                leaf2.rotation.y = (i / 4) * Math.PI * 2 + 0.5;
                leaf2.rotation.z = 0.6;
                group.add(leaf2);
            }

            group.position.set(x, 0, z);
            return group;
        }

        // Ø¥Ø¶Ø§ÙØ© Ù†Ø®ÙŠÙ„ ÙÙŠ Ø§Ù„ØµØ­Ø±Ø§Ø¡
        for (let i = 0; i < 25; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 15 + Math.random() * 50;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const palm = createPalmTree(x, z);
            scene.add(palm);
        }

        // --- Ø­ÙŠÙˆØ§Ù†Ø§Øª ØµØ­Ø±Ø§ÙˆÙŠØ©: Ø¬Ù…Ù„ ÙˆØ«Ø¹Ø¨Ø§Ù† ---
        function createCamel(x, z) {
            const group = new THREE.Group();
            const camelMat = new THREE.MeshStandardMaterial({ color: 0xc99a6b, roughness: 0.7 });
            const darkMat = new THREE.MeshStandardMaterial({ color: 0x7a4d2e });

            // Ø¬Ø³Ù…
            const bodyGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.8);
            const body = new THREE.Mesh(bodyGeo, camelMat);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 1.0;
            body.rotation.z = 0.1;
            group.add(body);

            // Ø±Ø£Ø³
            const headGeo = new THREE.SphereGeometry(0.5);
            const head = new THREE.Mesh(headGeo, camelMat);
            head.castShadow = true;
            head.receiveShadow = true;
            head.position.set(1.2, 1.6, 0);
            group.add(head);

            // Ø£Ø°Ù†Ø§Ù† ØµØºÙŠØ±ØªØ§Ù†
            const earGeo = new THREE.ConeGeometry(0.2, 0.4);
            const earL = new THREE.Mesh(earGeo, darkMat);
            earL.position.set(0.8, 2.0, 0.3);
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, darkMat);
            earR.position.set(0.8, 2.0, -0.3);
            group.add(earR);

            // Ø³Ù†Ø§Ù…
            const humpGeo = new THREE.ConeGeometry(0.7, 0.9);
            const hump = new THREE.Mesh(humpGeo, darkMat);
            hump.position.set(-0.2, 1.7, 0);
            hump.rotation.x = 0.2;
            group.add(hump);

            // Ø£Ø±Ø¬Ù„
            const legGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.0);
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(legGeo, camelMat);
                leg.castShadow = true;
                leg.receiveShadow = true;
                const xOff = i < 2 ? -0.6 : 0.6;
                const zOff = i % 2 === 0 ? 0.5 : -0.5;
                leg.position.set(xOff, 0.5, zOff);
                group.add(leg);
            }

            group.position.set(x, 0, z);
            return group;
        }

        function createSnake(x, z) {
            const group = new THREE.Group();
            const snakeMat = new THREE.MeshStandardMaterial({ color: 0x5d8c6b, roughness: 0.5 });

            // Ø¬Ø³Ù… Ø«Ø¹Ø¨Ø§Ù† Ø¨Ø³ÙŠØ· (ÙƒØ±Ø§Øª Ù…ØªØµÙ„Ø©)
            for (let i = 0; i < 5; i++) {
                const segment = new THREE.Mesh(new THREE.SphereGeometry(0.3 + i*0.02, 6), snakeMat);
                segment.castShadow = true;
                segment.receiveShadow = true;
                segment.position.set(i * 0.4, 0.2, 0);
                group.add(segment);
            }
            // Ø±Ø£Ø³
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.6), snakeMat);
            head.position.set(1.8, 0.25, 0);
            head.rotation.z = Math.PI / 2;
            group.add(head);

            group.position.set(x, 0, z);
            group.rotation.y = Math.random() * Math.PI;
            return group;
        }

        const camel1 = createCamel(25, 10);
        const camel2 = createCamel(-20, 30);
        const snake1 = createSnake(5, -15);
        scene.add(camel1);
        scene.add(camel2);
        scene.add(snake1);

        // --- Ø¨Ø¹Ø¶ Ø§Ù„ØµØ®ÙˆØ± Ù„ØªØ²ÙŠÙŠÙ† Ø§Ù„ØµØ­Ø±Ø§Ø¡ ---
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x7a6a5a, roughness: 0.9 });
        for (let i = 0; i < 40; i++) {
            const rockGeo = new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.8);
            const rock = new THREE.Mesh(rockGeo, rockMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 8 + Math.random() * 40;
            rock.position.set(Math.cos(angle) * radius, 0.3, Math.sin(angle) * radius);
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
        }

        // --- Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ© (Ù…Ø«Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚) ---
        const keyState = { w: false, a: false, s: false, d: false };

        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD' || e.code === 'KeyC') {
                e.preventDefault();
            }
            switch(e.code) {
                case 'KeyW': keyState.w = true; break;
                case 'KeyA': keyState.a = true; break;
                case 'KeyS': keyState.s = true; break;
                case 'KeyD': keyState.d = true; break;
                case 'KeyC':
                    activeCamera = (activeCamera === cameraFollow) ? cameraFree : cameraFollow;
                    controls.enabled = (activeCamera === cameraFree);
                    document.getElementById('cam-status').innerText = 
                        activeCamera === cameraFollow ? 'ğŸ“· ÙƒØ§Ù…ÙŠØ±Ø§: Ø®Ù„ÙÙŠØ©' : 'ğŸ“· ÙƒØ§Ù…ÙŠØ±Ø§: Ø­Ø±Ø©';
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD') e.preventDefault();
            switch(e.code) {
                case 'KeyW': keyState.w = false; break;
                case 'KeyA': keyState.a = false; break;
                case 'KeyS': keyState.s = false; break;
                case 'KeyD': keyState.d = false; break;
            }
        });

        // Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù„Ù…Ø³
        const btnW = document.getElementById('btn-w');
        const btnA = document.getElementById('btn-a');
        const btnS = document.getElementById('btn-s');
        const btnD = document.getElementById('btn-d');
        const btnC = document.getElementById('btn-c');

        function setActive(btn, state) {
            if (state) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        btnW.addEventListener('touchstart', (e) => { e.preventDefault(); keyState.w = true; setActive(btnW, true); });
        btnW.addEventListener('touchend', (e) => { e.preventDefault(); keyState.w = false; setActive(btnW, false); });
        btnW.addEventListener('touchcancel', (e) => { e.preventDefault(); keyState.w = false; setActive(btnW, false); });

        btnA.addEventListener('touchstart', (e) => { e.preventDefault(); keyState.a = true; setActive(btnA, true); });
        btnA.addEventListener('touchend', (e) => { e.preventDefault(); keyState.a = false; setActive(btnA, false); });
        btnA.addEventListener('touchcancel', (e) => { e.preventDefault(); keyState.a = false; setActive(btnA, false); });

        btnS.addEventListener('touchstart', (e) => { e.preventDefault(); keyState.s = true; setActive(btnS, true); });
        btnS.addEventListener('touchend', (e) => { e.preventDefault(); keyState.s = false; setActive(btnS, false); });
        btnS.addEventListener('touchcancel', (e) => { e.preventDefault(); keyState.s = false; setActive(btnS, false); });

        btnD.addEventListener('touchstart', (e) => { e.preventDefault(); keyState.d = true; setActive(btnD, true); });
        btnD.addEventListener('touchend', (e) => { e.preventDefault(); keyState.d = false; setActive(btnD, false); });
        btnD.addEventListener('touchcancel', (e) => { e.preventDefault(); keyState.d = false; setActive(btnD, false); });

        btnC.addEventListener('touchstart', (e) => {
            e.preventDefault();
            activeCamera = (activeCamera === cameraFollow) ? cameraFree : cameraFollow;
            controls.enabled = (activeCamera === cameraFree);
            document.getElementById('cam-status').innerText = 
                activeCamera === cameraFollow ? 'ğŸ“· ÙƒØ§Ù…ÙŠØ±Ø§: Ø®Ù„ÙÙŠØ©' : 'ğŸ“· ÙƒØ§Ù…ÙŠØ±Ø§: Ø­Ø±Ø©';
        });

        // Ù†Ø³Ø® Ù„Ù„ÙØ£Ø±Ø©
        btnW.addEventListener('mousedown', (e) => { e.preventDefault(); keyState.w = true; setActive(btnW, true); });
        btnW.addEventListener('mouseup', (e) => { e.preventDefault(); keyState.w = false; setActive(btnW, false); });
        btnW.addEventListener('mouseleave', (e) => { keyState.w = false; setActive(btnW, false); });
        btnA.addEventListener('mousedown', (e) => { e.preventDefault(); keyState.a = true; setActive(btnA, true); });
        btnA.addEventListener('mouseup', (e) => { e.preventDefault(); keyState.a = false; setActive(btnA, false); });
        btnA.addEventListener('mouseleave', (e) => { keyState.a = false; setActive(btnA, false); });
        btnS.addEventListener('mousedown', (e) => { e.preventDefault(); keyState.s = true; setActive(btnS, true); });
        btnS.addEventListener('mouseup', (e) => { e.preventDefault(); keyState.s = false; setActive(btnS, false); });
        btnS.addEventListener('mouseleave', (e) => { keyState.s = false; setActive(btnS, false); });
        btnD.addEventListener('mousedown', (e) => { e.preventDefault(); keyState.d = true; setActive(btnD, true); });
        btnD.addEventListener('mouseup', (e) => { e.preventDefault(); keyState.d = false; setActive(btnD, false); });
        btnD.addEventListener('mouseleave', (e) => { keyState.d = false; setActive(btnD, false); });
        btnC.addEventListener('click', (e) => {
            e.preventDefault();
            activeCamera = (activeCamera === cameraFollow) ? cameraFree : cameraFollow;
            controls.enabled = (activeCamera === cameraFree);
            document.getElementById('cam-status').innerText = 
                activeCamera === cameraFollow ? 'ğŸ“· ÙƒØ§Ù…ÙŠØ±Ø§: Ø®Ù„ÙÙŠØ©' : 'ğŸ“· ÙƒØ§Ù…ÙŠØ±Ø§: Ø­Ø±Ø©';
        });

        // --- Ø­Ù„Ù‚Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ---
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000;

            // Ø­Ø±ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ©
            const speed = 0.25;
            if (keyState.w) player.position.z -= speed;
            if (keyState.s) player.position.z += speed;
            if (keyState.a) player.position.x -= speed;
            if (keyState.d) player.position.x += speed;

            // ØªØ­Ø¯ÙŠØ« ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„ØªØªØ¨Ø¹
            if (activeCamera === cameraFollow) {
                const offset = new THREE.Vector3(-4, 3, 5);
                cameraFollow.position.copy(player.position.clone().add(offset));
                cameraFollow.lookAt(player.position);
            } else {
                controls.update();
            }

            // Ø­Ø±ÙƒØ© Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø³ÙŠØ·Ø© (Ø§Ø±ØªÙØ§Ø¹ Ø·ÙÙŠÙ)
            camel1.position.y = 0.5 + Math.sin(elapsedTime * 2) * 0.05;
            camel2.position.y = 0.5 + Math.cos(elapsedTime * 3) * 0.05;
            snake1.rotation.y += 0.005;

            renderer.render(scene, activeCamera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø© ---
        window.addEventListener('resize', () => {
            cameraFollow.aspect = window.innerWidth / window.innerHeight;
            cameraFollow.updateProjectionMatrix();
            cameraFree.aspect = window.innerWidth / window.innerHeight;
            cameraFree.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        console.log('ğŸœï¸ Ù„Ø¹Ø¨Ø© Ø§Ù„ØµØ­Ø±Ø§Ø¡ Ø¬Ø§Ù‡Ø²Ø©!');
    </script>
</body>
</html>
