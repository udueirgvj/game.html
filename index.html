<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ø¹Ø§Ù„Ù… Ø§Ù„ØºØ§Ø¨Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ - Ø¬ÙˆØ¯Ø© 4K</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: black; }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 8px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.2);
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            background: rgba(0,0,0,0.6);
            padding: 20px 40px;
            border-radius: 10px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loading">Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠ...</div>
    <div id="info">ğŸŒ³ ØºØ§Ø¨Ø© 4K | WASD Ù„Ù„ØªØ¬ÙˆÙ„ | C Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ | Ø§Ø¶ØºØ· F Ù„Ø¹Ø±Ø¶ 4K</div>

    <!-- Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { Water } from 'three/addons/objects/Water.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ø±Ù†Ø¯Ø± Ø¨Ø¯Ù‚Ø© 4K ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaccff);
        scene.fog = new THREE.FogExp2(0xaaccff, 0.0015); // Ø¶Ø¨Ø§Ø¨ Ø®ÙÙŠÙ Ù„Ù„Ø¹Ù…Ù‚

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance", precision: "highp" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.bias = 0.0001;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputEncoding = THREE.sRGBEncoding; // Ù„Ø§Ø­Ø¸: ÙÙŠ Three.js r128 Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ colorSpace
        document.body.appendChild(renderer.domElement);

        // --- Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ ---
        setTimeout(() => document.getElementById('loading').style.display = 'none', 2000);

        // --- Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª (ÙƒØ§Ù…ÙŠØ±Ø§ Ø­Ø±Ø© ÙˆÙƒØ§Ù…ÙŠØ±Ø§ ØªØªØ¨Ø¹) ---
        const cameraFree = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        cameraFree.position.set(30, 20, 50);

        const cameraFollow = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        cameraFollow.position.set(0, 5, 15);

        let activeCamera = cameraFree; // Ù†Ø¨Ø¯Ø£ Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø­Ø±Ø© Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ù…Ø´Ù‡Ø¯

        const controls = new OrbitControls(cameraFree, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.enableZoom = true;
        controls.target.set(20, 5, 20); // Ù†Ù‚Ø·Ø© Ù…Ø±ÙƒØ²ÙŠØ© ÙÙŠ Ø§Ù„ØºØ§Ø¨Ø©

        // --- Ø¥Ø¶Ø§Ø¡Ø© Ù…Ø­ÙŠØ·Ø© Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø¬ÙˆØ¯Ø© ---
        const hemiLight = new THREE.HemisphereLight(0x88ccff, 0x335511, 1.2);
        scene.add(hemiLight);

        // --- Ø¥Ø¶Ø§Ø¡Ø© Ø´Ù…Ø³ÙŠØ© Ù…Ø¹ Ø¸Ù„Ø§Ù„ Ù†Ø§Ø¹Ù…Ø© ---
        const sunLight = new THREE.DirectionalLight(0xffeedd, 1.5);
        sunLight.position.set(30, 40, 20);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096; // Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© Ø¬Ø¯Ø§Ù‹ Ù„Ù„Ø¸Ù„Ø§Ù„
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 150;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        sunLight.shadow.bias = -0.0005;
        sunLight.shadow.normalBias = 0.02;
        scene.add(sunLight);

        // --- Ø¥Ø¶Ø§Ø¡Ø© Ø®Ù„ÙÙŠØ© Ø¯Ø§ÙØ¦Ø© ---
        const backLight = new THREE.DirectionalLight(0xffaa66, 0.6);
        backLight.position.set(-20, 20, -30);
        scene.add(backLight);

        // --- Ø³Ù…Ø§Ø¡ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© (Sky) Ù…Ø¹ ØºÙŠÙˆÙ… ---
        const sky = new Sky();
        sky.scale.setScalar(450);
        scene.add(sky);

        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 8;
        skyUniforms['rayleigh'].value = 1.5;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;
        skyUniforms['sunPosition'].value.set(30, 30, 20);

        // --- Ø£Ø±Ø¶ÙŠØ© Ø¨ØªØ¶Ø§Ø±ÙŠØ³ Ù…ØªÙ†ÙˆØ¹Ø© (Ù†Ø³ØªØ®Ø¯Ù… Ù†Ø³ÙŠØ¬ Ø¹Ø§Ù„ÙŠ Ø§Ù„Ø¯Ù‚Ø©) ---
        const textureLoader = new THREE.TextureLoader();
        
        // ØªØ­Ù…ÙŠÙ„ Ø£Ù†Ø³Ø¬Ø© 4K Ù…Ù† Ù…ØµØ§Ø¯Ø± Ø®Ø§Ø±Ø¬ÙŠØ© (Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø§ØªØµØ§Ù„ Ø¥Ù†ØªØ±Ù†Øª Ø³Ø±ÙŠØ¹)
        const grassColor = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_diff_1k.jpg');
        const grassNormal = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_nor_gl_1k.jpg');
        const grassRough = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_rough_1k.jpg');
        const grassDisp = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_disp_1k.jpg');

        // ØªÙƒØ±Ø§Ø± Ø§Ù„Ù†Ø³ÙŠØ¬
        [grassColor, grassNormal, grassRough, grassDisp].forEach(tex => {
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(20, 20);
        });

        // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø±Ø¶ÙŠØ© ÙƒØ¨ÙŠØ±Ø© Ù…Ø¹ ØªØ¶Ø§Ø±ÙŠØ³ (Ø§Ø³ØªØ®Ø¯Ø§Ù… PlaneGeometry Ù…Ø¹ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹Ø§Øª)
        const groundGeo = new THREE.PlaneGeometry(200, 200, 256, 256); // subdivisions Ø¹Ø§Ù„ÙŠØ© Ù„Ù„ØªÙØ§ØµÙŠÙ„
        const groundMat = new THREE.MeshStandardMaterial({
            map: grassColor,
            normalMap: grassNormal,
            roughnessMap: grassRough,
            displacementMap: grassDisp,
            displacementScale: 2.5,
            roughness: 0.7,
            metalness: 0.1,
            color: 0xffffff
        });

        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.5; // Ù„Ø£Ø³ÙÙ„ Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø­ÙˆØ§Ù
        ground.receiveShadow = true;
        ground.castShadow = false;
        scene.add(ground);

        // --- Ø¥Ø¶Ø§ÙØ© ØªÙ„Ø§Ù„ ØµØºÙŠØ±Ø© (Ù…ÙƒØ±Ø±Ø©) Ù„ØªØ¹Ø²ÙŠØ² Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ© ---
        const hillMat = new THREE.MeshStandardMaterial({ color: 0x5a7a4a, roughness: 0.8, emissive: 0x112211 });
        for (let i = 0; i < 30; i++) {
            const hillGeo = new THREE.ConeGeometry(1 + Math.random() * 3, 1 + Math.random() * 2, 8);
            const hill = new THREE.Mesh(hillGeo, hillMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 60;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            hill.position.set(x, 0.2, z);
            hill.castShadow = true;
            hill.receiveShadow = true;
            scene.add(hill);
        }

        // --- Ø¹Ø´Ø¨ ÙƒØ«ÙŠÙ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… InstancedMesh (Ø¢Ù„Ø§Ù Ø§Ù„Ù‚Ø·Ø¹) Ù…Ø¹ Ø­Ø±ÙƒØ© Ø§Ù„Ø±ÙŠØ§Ø­ ---
        const bladeGeo = new THREE.ConeGeometry(0.15, 0.6, 4);
        const bladeMat = new THREE.MeshStandardMaterial({ color: 0x4a7a4a, emissive: 0x112211 });
        const bladeCount = 20000;
        const instancedGrass = new THREE.InstancedMesh(bladeGeo, bladeMat, bladeCount);
        instancedGrass.castShadow = true;
        instancedGrass.receiveShadow = true;

        const dummy = new THREE.Object3D();
        for (let i = 0; i < bladeCount; i++) {
            const radius = 20 + Math.random() * 90;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            dummy.position.set(x, 0.3, z);
            dummy.rotation.y = Math.random() * Math.PI;
            dummy.scale.set(1, 0.8 + Math.random() * 0.7, 1);
            dummy.updateMatrix();
            instancedGrass.setMatrixAt(i, dummy.matrix);
        }
        instancedGrass.instanceMatrix.needsUpdate = true;
        scene.add(instancedGrass);

        // --- Ø£Ø²Ù‡Ø§Ø± Ù…Ù„ÙˆÙ†Ø© Ø¨Ø£Ø´ÙƒØ§Ù„ Ù…Ø®ØªÙ„ÙØ© ---
        const flowerColors = [0xff4d4d, 0xff9f4d, 0xffeb4d, 0x9f4dff, 0x4dffdb];
        const flowerMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // Ø³Ù†ØºÙŠØ± Ø§Ù„Ù„ÙˆÙ† Ù„ÙƒÙ„ Ø²Ù‡Ø±Ø©
        const flowerGeo = new THREE.ConeGeometry(0.2, 0.3, 6);
        
        for (let i = 0; i < 800; i++) {
            const flower = new THREE.Mesh(flowerGeo, new THREE.MeshStandardMaterial({ color: flowerColors[Math.floor(Math.random() * flowerColors.length)] }));
            const angle = Math.random() * Math.PI * 2;
            const radius = 10 + Math.random() * 70;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            flower.position.set(x, 0.2, z);
            flower.castShadow = true;
            flower.receiveShadow = true;
            scene.add(flower);
        }

        // --- Ø£Ø´Ø¬Ø§Ø± ÙˆØ§Ù‚Ø¹ÙŠØ© (Ù†ÙˆØ¹Ø§Ù†: ØµÙ†ÙˆØ¨Ø± ÙˆÙƒØ³ØªÙ†Ø§Ø¡) ---
        function createTreePine(x, z) {
            const group = new THREE.Group();
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6b4c3b, roughness: 0.8 });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2d6a4f, roughness: 0.4, emissive: 0x112211 });

            // Ø¬Ø°Ø¹
            const trunkGeo = new THREE.CylinderGeometry(0.8, 1.2, 5);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = 2.5;
            group.add(trunk);

            // ÙØ±ÙˆØ¹ Ø¬Ø§Ù†Ø¨ÙŠØ©
            const branchGeo = new THREE.CylinderGeometry(0.3, 0.4, 2);
            for (let i = 0; i < 3; i++) {
                const branch = new THREE.Mesh(branchGeo, trunkMat);
                branch.castShadow = true;
                branch.receiveShadow = true;
                branch.position.set(0.7 * Math.sin(i), 3 + i * 0.8, 0.7 * Math.cos(i));
                branch.rotation.z = 0.3;
                branch.rotation.y = i;
                group.add(branch);
            }

            // Ø£ÙˆØ±Ø§Ù‚ (ÙƒØ±Ø§Øª)
            const leafGeo = new THREE.SphereGeometry(1.2, 6);
            const leaf1 = new THREE.Mesh(leafGeo, leafMat);
            leaf1.castShadow = true;
            leaf1.receiveShadow = true;
            leaf1.position.set(0, 5, 0);
            group.add(leaf1);

            const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(1.0, 6), leafMat);
            leaf2.castShadow = true;
            leaf2.receiveShadow = true;
            leaf2.position.set(0.8, 4.2, 0.6);
            group.add(leaf2);

            const leaf3 = new THREE.Mesh(new THREE.SphereGeometry(1.0, 6), leafMat);
            leaf3.castShadow = true;
            leaf3.receiveShadow = true;
            leaf3.position.set(-0.7, 4.5, -0.5);
            group.add(leaf3);

            group.position.set(x, 0, z);
            return group;
        }

        function createTreeOak(x, z) {
            const group = new THREE.Group();
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x3A7734 });

            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.4, 6), trunkMat);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = 3;
            group.add(trunk);

            const leafGeo = new THREE.SphereGeometry(2.0, 5);
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.castShadow = true;
            leaf.receiveShadow = true;
            leaf.position.set(0, 5.5, 0);
            group.add(leaf);

            const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(1.5, 5), leafMat);
            leaf2.castShadow = true;
            leaf2.receiveShadow = true;
            leaf2.position.set(1.2, 4.5, 1.0);
            group.add(leaf2);

            const leaf3 = new THREE.Mesh(new THREE.SphereGeometry(1.5, 5), leafMat);
            leaf3.castShadow = true;
            leaf3.receiveShadow = true;
            leaf3.position.set(-1.1, 4.8, -1.2);
            group.add(leaf3);

            group.position.set(x, 0, z);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ 200 Ø´Ø¬Ø±Ø© ÙÙŠ Ø§Ù„ØºØ§Ø¨Ø©
        for (let i = 0; i < 200; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 15 + Math.random() * 70;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            if (i % 2 === 0) {
                scene.add(createTreePine(x, z));
            } else {
                scene.add(createTreeOak(x, z));
            }
        }

        // --- Ø­ÙŠÙˆØ§Ù†Ø§Øª (ØºØ²Ù„Ø§Ù† ÙˆØ£Ø±Ø§Ù†Ø¨) ---
        function createDeer(x, z) {
            const group = new THREE.Group();
            const brown = new THREE.MeshStandardMaterial({ color: 0xB87D4B });
            const lightBrown = new THREE.MeshStandardMaterial({ color: 0xE0A878 });

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.2), brown);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.8;
            body.rotation.z = 0.1;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), lightBrown);
            head.castShadow = true;
            head.receiveShadow = true;
            head.position.set(0.8, 1.2, 0.2);
            group.add(head);

            const legGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.8);
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(legGeo, brown);
                leg.castShadow = true;
                leg.receiveShadow = true;
                leg.position.set(i < 2 ? -0.4 : 0.4, 0.4, i % 2 === 0 ? 0.4 : -0.4);
                group.add(leg);
            }

            group.position.set(x, 0.3, z);
            return group;
        }

        function createRabbit(x, z) {
            const group = new THREE.Group();
            const white = new THREE.MeshStandardMaterial({ color: 0xF0F0F0 });
            const pink = new THREE.MeshStandardMaterial({ color: 0xFFAAAA });

            const body = new THREE.Mesh(new THREE.SphereGeometry(0.5), white);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.4;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), white);
            head.castShadow = true;
            head.receiveShadow = true;
            head.position.set(0, 0.8, 0.4);
            group.add(head);

            const earGeo = new THREE.ConeGeometry(0.15, 0.6);
            const earL = new THREE.Mesh(earGeo, pink);
            earL.position.set(-0.15, 1.1, 0.3);
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, pink);
            earR.position.set(0.15, 1.1, 0.3);
            group.add(earR);

            group.position.set(x, 0.1, z);
            return group;
        }

        // Ø¥Ø¶Ø§ÙØ© 20 Ø­ÙŠÙˆØ§Ù†Ø§Ù‹
        const deerPositions = [
            [25, 30], [-15, 40], [50, -20], [-30, -40], [10, -50]
        ];
        deerPositions.forEach(pos => scene.add(createDeer(pos[0], pos[1])));

        for (let i = 0; i < 15; i++) {
            const x = (Math.random() - 0.5) * 100;
            const z = (Math.random() - 0.5) * 100;
            scene.add(createRabbit(x, z));
        }

        // --- ÙØ±Ø§Ø´Ø§Øª (Ù†Ù‚Ø§Ø· Ù…ØªØ­Ø±ÙƒØ©) ---
        const butterflyGeo = new THREE.BoxGeometry(0.2, 0.05, 0.3);
        const butterflyMat = new THREE.MeshStandardMaterial({ color: 0xffaa00 });
        const butterflies = [];
        for (let i = 0; i < 30; i++) {
            const butterfly = new THREE.Mesh(butterflyGeo, butterflyMat);
            butterfly.castShadow = true;
            butterfly.receiveShadow = true;
            const x = (Math.random() - 0.5) * 120;
            const z = (Math.random() - 0.5) * 120;
            butterfly.position.set(x, 2 + Math.random() * 5, z);
            scene.add(butterfly);
            butterflies.push(butterfly);
        }

        // --- Ù†Ù‡Ø± (Ù…Ø§Ø¡) ---
        const waterGeometry = new THREE.CircleGeometry(40, 64);
        const water = new Water(waterGeometry, {
            textureWidth: 512,
            textureHeight: 512,
            waterNormals: textureLoader.load('https://threejs.org/examples/textures/water/Water_1_M_Normal.jpg'),
            sunDirection: new THREE.Vector3(1, 1, 1),
            sunColor: 0xffaa88,
            waterColor: 0x336699,
            distortionScale: 3.7,
            fog: true
        });
        water.rotation.x = -Math.PI / 2;
        water.position.set(40, 0.2, 30);
        water.receiveShadow = true;
        scene.add(water);

        // --- ØµØ®ÙˆØ± Ù…ØªÙ†Ø§Ø«Ø±Ø© ---
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x6a6a6a, roughness: 0.9 });
        for (let i = 0; i < 50; i++) {
            const rockGeo = new THREE.DodecahedronGeometry(0.5 + Math.random() * 1.5);
            const rock = new THREE.Mesh(rockGeo, rockMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 10 + Math.random() * 60;
            rock.position.set(Math.cos(angle) * radius, 0.3, Math.sin(angle) * radius);
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
        }

        // --- Ø´Ø®ØµÙŠØ© Ø¨Ø³ÙŠØ·Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) Ù„Ù„ØªØ­Ø±Ùƒ ---
        const playerGroup = new THREE.Group();
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x44aa88 });
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
        
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.5), bodyMat);
        body.castShadow = true;
        body.receiveShadow = true;
        body.position.y = 0.75;
        playerGroup.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), headMat);
        head.castShadow = true;
        head.receiveShadow = true;
        head.position.y = 1.6;
        playerGroup.add(head);

        playerGroup.position.set(20, 0.5, 20);
        scene.add(playerGroup);

        // --- Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ© (WASD) ÙˆÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„ØªØªØ¨Ø¹ ---
        const keyState = { w: false, a: false, s: false, d: false };

        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD' || e.code === 'KeyC' || e.code === 'KeyF') {
                e.preventDefault();
            }
            switch(e.code) {
                case 'KeyW': keyState.w = true; break;
                case 'KeyA': keyState.a = true; break;
                case 'KeyS': keyState.s = true; break;
                case 'KeyD': keyState.d = true; break;
                case 'KeyC':
                    activeCamera = (activeCamera === cameraFree) ? cameraFollow : cameraFree;
                    controls.enabled = (activeCamera === cameraFree);
                    break;
                case 'KeyF': // ØªØ¨Ø¯ÙŠÙ„ ÙˆØ¶Ø¹ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.body.requestFullscreen();
                    }
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD') e.preventDefault();
            switch(e.code) {
                case 'KeyW': keyState.w = false; break;
                case 'KeyA': keyState.a = false; break;
                case 'KeyS': keyState.s = false; break;
                case 'KeyD': keyState.d = false; break;
            }
        });

        // --- Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© ---
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000;

            // Ø­Ø±ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ©
            const speed = 0.3;
            if (keyState.w) playerGroup.position.z -= speed;
            if (keyState.s) playerGroup.position.z += speed;
            if (keyState.a) playerGroup.position.x -= speed;
            if (keyState.d) playerGroup.position.x += speed;

            // ØªØ­Ø¯ÙŠØ« ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„ØªØªØ¨Ø¹
            if (activeCamera === cameraFollow) {
                const offset = new THREE.Vector3(-5, 3, 7);
                cameraFollow.position.copy(playerGroup.position.clone().add(offset));
                cameraFollow.lookAt(playerGroup.position);
            } else {
                controls.update();
            }

            // Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø´Ø¨ (Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø±ÙŠØ§Ø­) - Ø¨Ø³ÙŠØ·Ø©
            instancedGrass.rotation.y += 0.0005;

            // Ø­Ø±ÙƒØ© Ø§Ù„ÙØ±Ø§Ø´Ø§Øª (Ø¯Ø§Ø¦Ø±ÙŠØ©)
            butterflies.forEach((butterfly, i) => {
                butterfly.position.y += Math.sin(elapsedTime * 2 + i) * 0.005;
                butterfly.rotation.y += 0.01;
            });

            // Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø§Ø¡
            water.material.uniforms['time'].value += delta;

            renderer.render(scene, activeCamera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø© ---
        window.addEventListener('resize', () => {
            cameraFree.aspect = window.innerWidth / window.innerHeight;
            cameraFree.updateProjectionMatrix();
            cameraFollow.aspect = window.innerWidth / window.innerHeight;
            cameraFollow.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
