<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ØºØ§Ø¨Ø© ÙˆØ§Ù‚Ø¹ÙŠØ© - Ø¬ÙˆØ¯Ø© 4K+</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: black;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 8px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            font-size: 16px;
            z-index: 100;
            pointer-events: none;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 28px;
            background: rgba(0,0,0,0.7);
            padding: 30px 60px;
            border-radius: 20px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255,255,255,0.2);
            text-align: center;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        #loading small {
            display: block;
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.8;
        }
        #stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #0f0;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(2px);
        }
    </style>
</head>
<body>
    <div id="loading">
        ğŸŒ³ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØºØ§Ø¨Ø© Ø§Ù„ÙˆØ§Ù‚Ø¹ÙŠØ©... 
        <small>Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ø¶Ø¹ Ø«ÙˆØ§Ù†Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„Ù‚ÙˆÙŠØ©</small>
    </div>
    <div id="info">ğŸŒ² ØºØ§Ø¨Ø© 4K+ | WASD Ù„Ù„ØªØ¬ÙˆÙ„ | C Ù„ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ | F Ù„ÙˆØ¶Ø¹ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©</div>
    <div id="stats">FPS: <span id="fps">0</span></div>

    <!-- Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { Water } from 'three/addons/objects/Water.js';
        
        // --- Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ ÙˆØ§Ù„Ø±Ù†Ø¯Ø± Ø¨Ø£Ù‚ØµÙ‰ Ø¬ÙˆØ¯Ø© ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaaccff);
        scene.fog = new THREE.FogExp2(0xaaccff, 0.0012); // Ø¶Ø¨Ø§Ø¨ Ø®ÙÙŠÙ Ù„Ù„ØºØ§ÙŠØ©

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø±Ù†Ø¯Ø± Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© Ù…Ø¹ anti-aliasing
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            powerPreference: "high-performance",
            precision: "highp",
            stencil: false,
            depth: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ© Ø¬Ø¯Ø§Ù‹ (ÙŠÙ…ÙƒÙ† Ø±ÙØ¹Ù‡Ø§ Ø¥Ù„Ù‰ 2.5 Ù„ÙƒÙ† Ù‚Ø¯ ÙŠØ¤Ø«Ø±)
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Ø¸Ù„Ø§Ù„ Ù†Ø§Ø¹Ù…Ø©
        renderer.shadowMap.autoUpdate = true;
        renderer.shadowMap.bias = 0.00005;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        renderer.outputEncoding = THREE.sRGBEncoding; // Ù„Ø§Ø­Ø¸: ÙÙŠ Three.js r128 Ù‚Ø¯ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ colorSpace
        document.body.appendChild(renderer.domElement);

        // --- Ø¥Ø®ÙØ§Ø¡ Ø´Ø§Ø´Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ø¹Ø¯ Ø«Ø§Ù†ÙŠØªÙŠÙ† ---
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
        }, 3000);

        // --- Ù†Ø¸Ø§Ù… Ø­Ø³Ø§Ø¨ FPS Ø¨Ø³ÙŠØ· ---
        let lastTime = performance.now();
        let frames = 0;
        const fpsSpan = document.getElementById('fps');
        setInterval(() => {
            const now = performance.now();
            const delta = now - lastTime;
            const fps = Math.round(1000 / delta * frames);
            fpsSpan.textContent = fps;
            frames = 0;
            lastTime = now;
        }, 1000);

        function countFrame() {
            frames++;
            requestAnimationFrame(countFrame);
        }
        countFrame();

        // --- Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§Øª (ÙƒØ§Ù…ÙŠØ±Ø§ Ø­Ø±Ø© Ù„ØªØ¬ÙˆØ§Ù„ Ø§Ù„Ø¹Ø§Ù„Ù… + ÙƒØ§Ù…ÙŠØ±Ø§ ØªØªØ¨Ø¹ Ù„Ø´Ø®ØµÙŠØ©) ---
        const cameraFree = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        cameraFree.position.set(40, 30, 60);
        cameraFree.lookAt(0, 10, 0);

        const cameraFollow = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        cameraFollow.position.set(10, 8, 20);

        let activeCamera = cameraFree; // Ù†Ø¨Ø¯Ø£ Ø¨Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø­Ø±Ø© Ù„Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ø¹Ø§Ù„Ù…

        const controls = new OrbitControls(cameraFree, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.enableZoom = true;
        controls.target.set(20, 10, 20);
        controls.maxDistance = 200;

        // --- Ø¥Ø¶Ø§Ø¡Ø© Ù…ØªØ·ÙˆØ±Ø© (Hemisphere + Directional + Point) ---
        // Ø¥Ø¶Ø§Ø¡Ø© Ù…Ø­ÙŠØ·Ø© Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø¡ ÙˆØ§Ù„Ø£Ø±Ø¶
        const hemiLight = new THREE.HemisphereLight(0x88ccff, 0x335511, 1.5);
        scene.add(hemiLight);

        // Ø¥Ø¶Ø§Ø¡Ø© Ø´Ù…Ø³ÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ© Ù…Ø¹ Ø¸Ù„Ø§Ù„ Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø¯Ù‚Ø©
        const sunLight = new THREE.DirectionalLight(0xffeedd, 1.8);
        sunLight.position.set(40, 60, 30);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 8192; // Ø¯Ù‚Ø© Ø¸Ù„Ø§Ù„ ÙØ§Ø¦Ù‚Ø© (4Kx4K)
        sunLight.shadow.mapSize.height = 8192;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 200;
        sunLight.shadow.camera.left = -70;
        sunLight.shadow.camera.right = 70;
        sunLight.shadow.camera.top = 70;
        sunLight.shadow.camera.bottom = -70;
        sunLight.shadow.bias = -0.0002;
        sunLight.shadow.normalBias = 0.02;
        sunLight.shadow.radius = 2; // Ù†ØµÙ Ù‚Ø·Ø± Ø§Ù„Ø¸Ù„ Ø§Ù„Ù†Ø§Ø¹Ù…
        scene.add(sunLight);

        // Ø¥Ø¶Ø§Ø¡Ø© Ø®Ù„ÙÙŠØ© Ø¯Ø§ÙØ¦Ø© Ù„ØªØ¹Ø²ÙŠØ² Ø§Ù„Ø¹Ù…Ù‚
        const backLight = new THREE.DirectionalLight(0xffaa66, 0.8);
        backLight.position.set(-30, 40, -50);
        scene.add(backLight);

        // Ø¥Ø¶Ø§Ø¡Ø© Ù†Ù‚Ø·ÙŠØ© Ø®ÙÙŠÙØ© ØªØ­Øª Ø§Ù„Ø£Ø´Ø¬Ø§Ø±
        const pointLight1 = new THREE.PointLight(0x88aa44, 0.5, 50);
        pointLight1.position.set(20, 5, 30);
        scene.add(pointLight1);
        
        const pointLight2 = new THREE.PointLight(0xaa8844, 0.5, 50);
        pointLight2.position.set(40, 8, 10);
        scene.add(pointLight2);

        // --- Ø³Ù…Ø§Ø¡ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠØ© (Sky) Ù…Ø¹ ØºÙŠÙˆÙ… Ù…ØªØ­Ø±ÙƒØ© (Ù…Ø­Ø§ÙƒØ§Ø©) ---
        const sky = new Sky();
        sky.scale.setScalar(500);
        scene.add(sky);

        const skyUniforms = sky.material.uniforms;
        skyUniforms['turbidity'].value = 8;
        skyUniforms['rayleigh'].value = 1.5;
        skyUniforms['mieCoefficient'].value = 0.005;
        skyUniforms['mieDirectionalG'].value = 0.8;
        skyUniforms['sunPosition'].value.copy(sunLight.position);

        // --- Ø£Ø±Ø¶ÙŠØ© Ø¨ØªØ¶Ø§Ø±ÙŠØ³ ÙˆØ¹Ø±Ø© (Ù†Ø³ØªØ®Ø¯Ù… Ù†Ø³ÙŠØ¬ Ø¹Ø§Ù„ÙŠ Ø§Ù„Ø¯Ù‚Ø© Ù…Ø¹ Ø¥Ø²Ø§Ø­Ø©) ---
        const textureLoader = new THREE.TextureLoader();
        
        // ØªØ­Ù…ÙŠÙ„ Ø£Ù†Ø³Ø¬Ø© Ø¹Ø§Ù„ÙŠØ© Ø§Ù„Ø¬ÙˆØ¯Ø© (4K) Ù…Ù† Ù…ØµØ§Ø¯Ø± Ù…ÙˆØ«ÙˆÙ‚Ø©
        const grassColor = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_diff_1k.jpg');
        const grassNormal = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_nor_gl_1k.jpg');
        const grassRough = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_rough_1k.jpg');
        const grassDisp = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grass_01_disp_1k.jpg');

        [grassColor, grassNormal, grassRough, grassDisp].forEach(tex => {
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(30, 30); // ØªÙƒØ±Ø§Ø± Ø§Ù„Ù†Ø³ÙŠØ¬ Ù„Ù…Ø³Ø§Ø­Ø© ÙˆØ§Ø³Ø¹Ø©
        });

        // Ø¥Ù†Ø´Ø§Ø¡ Ø£Ø±Ø¶ÙŠØ© ÙƒØ¨ÙŠØ±Ø© Ù…Ø¹ ØªØ¶Ø§Ø±ÙŠØ³ (256x256 ØªÙ‚Ø³ÙŠÙ…Ø§Øª Ù„ØªÙØ§ØµÙŠÙ„ Ø¯Ù‚ÙŠÙ‚Ø©)
        const groundGeo = new THREE.PlaneGeometry(300, 300, 256, 256);
        const groundMat = new THREE.MeshStandardMaterial({
            map: grassColor,
            normalMap: grassNormal,
            roughnessMap: grassRough,
            displacementMap: grassDisp,
            displacementScale: 4.0, // ØªØ¶Ø§Ø±ÙŠØ³ ÙˆØ§Ø¶Ø­Ø©
            roughness: 0.7,
            metalness: 0.1,
            color: 0xffffff,
            emissive: 0x000000
        });

        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.5; // Ù„Ø£Ø³ÙÙ„ Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø­ÙˆØ§Ù
        ground.receiveShadow = true;
        ground.castShadow = false;
        scene.add(ground);

        // --- ØªÙ„Ø§Ù„ ØµØºÙŠØ±Ø© Ø¥Ø¶Ø§ÙÙŠØ© (ØªØ¶Ø§Ø±ÙŠØ³ Ø¥Ø¶Ø§ÙÙŠØ©) ---
        const hillMat = new THREE.MeshStandardMaterial({ color: 0x5a7a4a, roughness: 0.9, emissive: 0x112211 });
        for (let i = 0; i < 40; i++) {
            const hillGeo = new THREE.ConeGeometry(2 + Math.random() * 5, 2 + Math.random() * 4, 8);
            const hill = new THREE.Mesh(hillGeo, hillMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 40 + Math.random() * 100;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            hill.position.set(x, 0.5, z);
            hill.castShadow = true;
            hill.receiveShadow = true;
            scene.add(hill);
        }

        // --- Ø¹Ø´Ø¨ ÙƒØ«ÙŠÙ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… InstancedMesh (30 Ø£Ù„Ù Ù‚Ø·Ø¹Ø©) ---
        const bladeGeo = new THREE.ConeGeometry(0.2, 0.8, 4);
        const bladeMat = new THREE.MeshStandardMaterial({ color: 0x4a7a4a, emissive: 0x112211 });
        const bladeCount = 30000; // ÙŠÙ…ÙƒÙ† ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„Ø¹Ø¯Ø¯ Ù„Ù„Ø£Ø¯Ø§Ø¡
        const instancedGrass = new THREE.InstancedMesh(bladeGeo, bladeMat, bladeCount);
        instancedGrass.castShadow = true;
        instancedGrass.receiveShadow = true;

        const dummy = new THREE.Object3D();
        for (let i = 0; i < bladeCount; i++) {
            const radius = 30 + Math.random() * 120;
            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            dummy.position.set(x, 0.3, z);
            dummy.rotation.y = Math.random() * Math.PI;
            dummy.scale.set(1, 0.7 + Math.random() * 0.8, 1);
            dummy.updateMatrix();
            instancedGrass.setMatrixAt(i, dummy.matrix);
        }
        instancedGrass.instanceMatrix.needsUpdate = true;
        scene.add(instancedGrass);

        // --- Ø£Ø²Ù‡Ø§Ø± Ù…Ù„ÙˆÙ†Ø© Ø¨Ø£Ø´ÙƒØ§Ù„ Ù…ØªÙ†ÙˆØ¹Ø© (2000 Ø²Ù‡Ø±Ø©) ---
        const flowerColors = [0xff3333, 0xff9933, 0xffdd33, 0xaa33ff, 0x33ffaa];
        const flowerGeo = new THREE.ConeGeometry(0.25, 0.4, 6);
        for (let i = 0; i < 2000; i++) {
            const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];
            const flowerMat = new THREE.MeshStandardMaterial({ color: color, emissive: 0x111111 });
            const flower = new THREE.Mesh(flowerGeo, flowerMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 100;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            flower.position.set(x, 0.25, z);
            flower.castShadow = true;
            flower.receiveShadow = true;
            scene.add(flower);
        }

        // --- Ø£Ø´Ø¬Ø§Ø± Ù…ØªÙ†ÙˆØ¹Ø© (3 Ø£Ù†ÙˆØ§Ø¹) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¯ÙˆØ§Ù„ Ù…Ù†ÙØµÙ„Ø© ---
        function createTreePine(x, z) {
            const group = new THREE.Group();
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6b4c3b, roughness: 0.9 });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2d6a4f, roughness: 0.5, emissive: 0x112211 });

            // Ø¬Ø°Ø¹
            const trunkGeo = new THREE.CylinderGeometry(0.8, 1.3, 6);
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = 3;
            group.add(trunk);

            // ÙØ±ÙˆØ¹ Ø¬Ø§Ù†Ø¨ÙŠØ©
            const branchGeo = new THREE.CylinderGeometry(0.3, 0.5, 2.5);
            for (let i = 0; i < 4; i++) {
                const branch = new THREE.Mesh(branchGeo, trunkMat);
                branch.castShadow = true;
                branch.receiveShadow = true;
                branch.position.set(Math.sin(i) * 1.2, 4 + i * 0.7, Math.cos(i) * 1.2);
                branch.rotation.z = 0.4;
                branch.rotation.y = i;
                group.add(branch);
            }

            // Ø£ÙˆØ±Ø§Ù‚ (ÙƒØ±Ø§Øª Ù…ØªØ¹Ø¯Ø¯Ø©)
            const leafGeo = new THREE.SphereGeometry(1.2, 7);
            const leaf1 = new THREE.Mesh(leafGeo, leafMat);
            leaf1.castShadow = true;
            leaf1.receiveShadow = true;
            leaf1.position.set(0, 6.5, 0);
            group.add(leaf1);

            const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(1.0, 7), leafMat);
            leaf2.castShadow = true;
            leaf2.receiveShadow = true;
            leaf2.position.set(1.0, 5.5, 0.8);
            group.add(leaf2);

            const leaf3 = new THREE.Mesh(new THREE.SphereGeometry(1.0, 7), leafMat);
            leaf3.castShadow = true;
            leaf3.receiveShadow = true;
            leaf3.position.set(-0.9, 6.0, -0.7);
            group.add(leaf3);

            group.position.set(x, 0, z);
            return group;
        }

        function createTreeOak(x, z) {
            const group = new THREE.Group();
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x3A7734 });

            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.8, 8), trunkMat);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = 4;
            group.add(trunk);

            const leafGeo = new THREE.SphereGeometry(2.2, 6);
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.castShadow = true;
            leaf.receiveShadow = true;
            leaf.position.set(0, 7.5, 0);
            group.add(leaf);

            const leaf2 = new THREE.Mesh(new THREE.SphereGeometry(1.8, 6), leafMat);
            leaf2.castShadow = true;
            leaf2.receiveShadow = true;
            leaf2.position.set(1.8, 6.2, 1.5);
            group.add(leaf2);

            const leaf3 = new THREE.Mesh(new THREE.SphereGeometry(1.8, 6), leafMat);
            leaf3.castShadow = true;
            leaf3.receiveShadow = true;
            leaf3.position.set(-1.5, 6.5, -1.3);
            group.add(leaf3);

            group.position.set(x, 0, z);
            return group;
        }

        function createTreePalm(x, z) {
            const group = new THREE.Group();
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2d6a4f });

            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 1.2, 7), trunkMat);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            trunk.position.y = 3.5;
            group.add(trunk);

            for (let i = 0; i < 6; i++) {
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(1.0, 2.5, 5), leafMat);
                leaf.castShadow = true;
                leaf.receiveShadow = true;
                leaf.position.set(0, 7, 0);
                leaf.rotation.y = (i / 6) * Math.PI * 2;
                leaf.rotation.z = 0.5;
                group.add(leaf);
            }

            group.position.set(x, 0, z);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ 500 Ø´Ø¬Ø±Ø© ÙÙŠ Ø§Ù„ØºØ§Ø¨Ø© (Ù„ØªØ¬Ù†Ø¨ Ø§Ù„Ø§Ø²Ø¯Ø­Ø§Ù…ØŒ Ù†ÙˆØ²Ø¹Ù‡Ø§ Ø¨Ø´ÙƒÙ„ Ø¯Ø§Ø¦Ø±ÙŠ)
        for (let i = 0; i < 500; i++) {
            const angle = Math.random() * Math.PI * 2;
            const radius = 30 + Math.random() * 120;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const type = Math.floor(Math.random() * 3);
            if (type === 0) scene.add(createTreePine(x, z));
            else if (type === 1) scene.add(createTreeOak(x, z));
            else scene.add(createTreePalm(x, z));
        }

        // --- Ø­ÙŠÙˆØ§Ù†Ø§Øª (ØºØ²Ù„Ø§Ù† ÙˆØ£Ø±Ø§Ù†Ø¨ ÙˆØ«Ø¹Ø§Ù„Ø¨) ---
        function createDeer(x, z) {
            const group = new THREE.Group();
            const brown = new THREE.MeshStandardMaterial({ color: 0xB87D4B });
            const lightBrown = new THREE.MeshStandardMaterial({ color: 0xE0A878 });

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.4), brown);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.9;
            body.rotation.z = 0.1;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.45), lightBrown);
            head.castShadow = true;
            head.receiveShadow = true;
            head.position.set(0.9, 1.3, 0.2);
            group.add(head);

            const legGeo = new THREE.CylinderGeometry(0.2, 0.2, 0.9);
            for (let i = 0; i < 4; i++) {
                const leg = new THREE.Mesh(legGeo, brown);
                leg.castShadow = true;
                leg.receiveShadow = true;
                leg.position.set(i < 2 ? -0.4 : 0.4, 0.45, i % 2 === 0 ? 0.5 : -0.5);
                group.add(leg);
            }

            // Ù‚Ø±ÙˆÙ† Ø¨Ø³ÙŠØ·Ø©
            const hornGeo = new THREE.ConeGeometry(0.15, 0.8);
            const hornMat = new THREE.MeshStandardMaterial({ color: 0x6a4a2a });
            const hornL = new THREE.Mesh(hornGeo, hornMat);
            hornL.position.set(0.5, 1.8, 0.2);
            hornL.rotation.z = -0.3;
            group.add(hornL);
            const hornR = new THREE.Mesh(hornGeo, hornMat);
            hornR.position.set(0.5, 1.8, 0.0);
            hornR.rotation.z = -0.3;
            group.add(hornR);

            group.position.set(x, 0.3, z);
            return group;
        }

        function createRabbit(x, z) {
            const group = new THREE.Group();
            const white = new THREE.MeshStandardMaterial({ color: 0xF0F0F0 });
            const pink = new THREE.MeshStandardMaterial({ color: 0xFFAAAA });

            const body = new THREE.Mesh(new THREE.SphereGeometry(0.5), white);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.4;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.3), white);
            head.castShadow = true;
            head.receiveShadow = true;
            head.position.set(0, 0.8, 0.4);
            group.add(head);

            const earGeo = new THREE.ConeGeometry(0.15, 0.7);
            const earL = new THREE.Mesh(earGeo, pink);
            earL.position.set(-0.15, 1.1, 0.3);
            earL.rotation.z = -0.2;
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, pink);
            earR.position.set(0.15, 1.1, 0.3);
            earR.rotation.z = 0.2;
            group.add(earR);

            group.position.set(x, 0.1, z);
            return group;
        }

        function createFox(x, z) {
            const group = new THREE.Group();
            const orange = new THREE.MeshStandardMaterial({ color: 0xCC8844 });
            const white = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.2), orange);
            body.castShadow = true;
            body.receiveShadow = true;
            body.position.y = 0.7;
            group.add(body);

            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), orange);
            head.castShadow = true;
            head.receiveShadow = true;
            head.position.set(0.7, 1.0, 0.2);
            group.add(head);

            const tail = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.9), orange);
            tail.castShadow = true;
            tail.receiveShadow = true;
            tail.position.set(-0.6, 0.8, -0.3);
            tail.rotation.x = 0.5;
            group.add(tail);

            group.position.set(x, 0.2, z);
            return group;
        }

        // ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø­ÙŠÙˆØ§Ù†Ø§Øª
        for (let i = 0; i < 25; i++) {
            const x = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;
            if (i % 3 === 0) scene.add(createDeer(x, z));
            else if (i % 3 === 1) scene.add(createRabbit(x, z));
            else scene.add(createFox(x, z));
        }

        // --- ÙØ±Ø§Ø´Ø§Øª (Ù…Ø¬Ù…ÙˆØ¹Ø§Øª Ù…ØªØ­Ø±ÙƒØ©) ---
        const butterflyGeo = new THREE.BoxGeometry(0.15, 0.03, 0.25);
        const butterflyMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 });
        const butterflies = [];
        for (let i = 0; i < 60; i++) {
            const butterfly = new THREE.Mesh(butterflyGeo, butterflyMat);
            butterfly.castShadow = true;
            butterfly.receiveShadow = true;
            const x = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;
            butterfly.position.set(x, 2 + Math.random() * 8, z);
            scene.add(butterfly);
            butterflies.push(butterfly);
        }

        // --- Ù†Ù‡Ø± (Ù…Ø§Ø¡ Ø¯ÙŠÙ†Ø§Ù…ÙŠÙƒÙŠ) ---
        const waterGeometry = new THREE.CircleGeometry(50, 128);
        const water = new Water(waterGeometry, {
            textureWidth: 1024,
            textureHeight: 1024,
            waterNormals: textureLoader.load('https://threejs.org/examples/textures/water/Water_1_M_Normal.jpg'),
            sunDirection: sunLight.position.clone().normalize(),
            sunColor: 0xffaa88,
            waterColor: 0x336699,
            distortionScale: 4.0,
            fog: true
        });
        water.rotation.x = -Math.PI / 2;
        water.position.set(60, 0.3, 40);
        water.receiveShadow = true;
        scene.add(water);

        // --- ØµØ®ÙˆØ± Ø¨Ø£Ø­Ø¬Ø§Ù… Ù…Ø®ØªÙ„ÙØ© ---
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x6a6a6a, roughness: 0.9, emissive: 0x111111 });
        for (let i = 0; i < 80; i++) {
            const rockGeo = new THREE.DodecahedronGeometry(0.7 + Math.random() * 2.5, 1);
            const rock = new THREE.Mesh(rockGeo, rockMat);
            const angle = Math.random() * Math.PI * 2;
            const radius = 20 + Math.random() * 110;
            rock.position.set(Math.cos(angle) * radius, 0.3, Math.sin(angle) * radius);
            rock.castShadow = true;
            rock.receiveShadow = true;
            rock.scale.set(1, 0.6 + Math.random() * 0.8, 1);
            scene.add(rock);
        }

        // --- Ø´Ø®ØµÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ© Ø¨Ø³ÙŠØ·Ø© (Ù„Ù„ØªØ¬ÙˆÙ„) ---
        const playerGroup = new THREE.Group();
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x44aa88 });
        const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
        
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.6), bodyMat);
        body.castShadow = true;
        body.receiveShadow = true;
        body.position.y = 0.8;
        playerGroup.add(body);

        const head = new THREE.Mesh(new THREE.SphereGeometry(0.4), headMat);
        head.castShadow = true;
        head.receiveShadow = true;
        head.position.y = 1.7;
        playerGroup.add(head);

        // Ø£Ø°Ø±Ø¹ ÙˆØ£Ø±Ø¬Ù„ Ù…Ø¨Ø³Ø·Ø©
        const armGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.9);
        const armMat = new THREE.MeshStandardMaterial({ color: 0x44aa88 });
        const armL = new THREE.Mesh(armGeo, armMat);
        armL.castShadow = true;
        armL.receiveShadow = true;
        armL.position.set(-0.7, 1.2, 0);
        armL.rotation.z = 0.2;
        playerGroup.add(armL);
        const armR = new THREE.Mesh(armGeo, armMat);
        armR.castShadow = true;
        armR.receiveShadow = true;
        armR.position.set(0.7, 1.2, 0);
        armR.rotation.z = -0.2;
        playerGroup.add(armR);

        const legGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.0);
        const legMat = new THREE.MeshStandardMaterial({ color: 0x337766 });
        const legL = new THREE.Mesh(legGeo, legMat);
        legL.castShadow = true;
        legL.receiveShadow = true;
        legL.position.set(-0.25, 0.3, 0);
        playerGroup.add(legL);
        const legR = new THREE.Mesh(legGeo, legMat);
        legR.castShadow = true;
        legR.receiveShadow = true;
        legR.position.set(0.25, 0.3, 0);
        playerGroup.add(legR);

        playerGroup.position.set(20, 0.6, 20);
        scene.add(playerGroup);

        // --- Ø§Ù„ØªØ­ÙƒÙ… Ø¨Ø§Ù„Ø´Ø®ØµÙŠØ© (WASD) ÙˆÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„ØªØªØ¨Ø¹ ---
        const keyState = { w: false, a: false, s: false, d: false };

        window.addEventListener('keydown', (e) => {
            if (e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD' || e.code === 'KeyC' || e.code === 'KeyF') {
                e.preventDefault();
            }
            switch(e.code) {
                case 'KeyW': keyState.w = true; break;
                case 'KeyA': keyState.a = true; break;
                case 'KeyS': keyState.s = true; break;
                case 'KeyD': keyState.d = true; break;
                case 'KeyC':
                    activeCamera = (activeCamera === cameraFree) ? cameraFollow : cameraFree;
                    controls.enabled = (activeCamera === cameraFree);
                    break;
                case 'KeyF':
                    if (document.fullscreenElement) {
                        document.exitFullscreen();
                    } else {
                        document.body.requestFullscreen();
                    }
                    break;
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'KeyW' || e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyD') e.preventDefault();
            switch(e.code) {
                case 'KeyW': keyState.w = false; break;
                case 'KeyA': keyState.a = false; break;
                case 'KeyS': keyState.s = false; break;
                case 'KeyD': keyState.d = false; break;
            }
        });

        // --- Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø³ÙˆÙ… Ø§Ù„Ù…ØªØ­Ø±ÙƒØ© ---
        const clock = new THREE.Clock();

        function animate() {
            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000;

            // Ø­Ø±ÙƒØ© Ø§Ù„Ø´Ø®ØµÙŠØ©
            const speed = 0.4;
            if (keyState.w) playerGroup.position.z -= speed;
            if (keyState.s) playerGroup.position.z += speed;
            if (keyState.a) playerGroup.position.x -= speed;
            if (keyState.d) playerGroup.position.x += speed;

            // ØªØ­Ø¯ÙŠØ« ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„ØªØªØ¨Ø¹
            if (activeCamera === cameraFollow) {
                const offset = new THREE.Vector3(-6, 4, 8);
                cameraFollow.position.copy(playerGroup.position.clone().add(offset));
                cameraFollow.lookAt(playerGroup.position);
            } else {
                controls.update();
            }

            // Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø´Ø¨ (ØªÙ…Ø§ÙŠÙ„ Ø¨Ø³ÙŠØ·)
            instancedGrass.rotation.y += 0.0003;

            // Ø­Ø±ÙƒØ© Ø§Ù„ÙØ±Ø§Ø´Ø§Øª (Ø§Ø±ØªÙØ§Ø¹ ÙˆÙ‡Ø¨ÙˆØ·)
            butterflies.forEach((butterfly, i) => {
                butterfly.position.y += Math.sin(elapsedTime * 2 + i) * 0.005;
                butterfly.rotation.y += 0.01;
            });

            // Ø­Ø±ÙƒØ© Ø§Ù„Ù…Ø§Ø¡
            water.material.uniforms['time'].value += delta;

            renderer.render(scene, activeCamera);
            requestAnimationFrame(animate);
        }

        animate();

        // --- ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø© ---
        window.addEventListener('resize', () => {
            cameraFree.aspect = window.innerWidth / window.innerHeight;
            cameraFree.updateProjectionMatrix();
            cameraFollow.aspect = window.innerWidth / window.innerHeight;
            cameraFollow.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
